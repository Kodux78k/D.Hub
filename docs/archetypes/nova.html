<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <title>Nova • Icosaedro</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root {
      --bg: transparent;                 /* transparente para casar com o HUB */
      --line: #ff52b1;                    /* cor principal (arquetipo) */
      --ballOpacity: 0.68;               /* opacidade da “bolinha” (mesh/wireframe) */
      --bloomStrength: 0.85;             /* 0.0–2.0 (força do bloom) */
      --bloomRadius: 0.22;               /* 0.0–1.0 (raio do bloom) */
      --bloomThreshold: 0.24;            /* 0.0–1.0 (limiar do bloom) */
      --rotateSpeed: 0.55;               /* rotações/seg (base) */
      --breath: 0.08;                    /* intensidade de “respiração” (0–0.2) */
      --wireOpacity: 0.35;               /* opacidade do contorno */
    }
    html,body{height:100%}
    body{margin:0;background:var(--bg);overflow:hidden;color:#eaf6ff;font:14px/1.4 ui-sans-serif,system-ui}
    canvas{position:fixed;inset:0;width:100%;height:100%;display:block}
    .label{
      position:fixed;left:0;right:0;bottom:10px;text-align:center;
      letter-spacing:.08em;text-transform:uppercase;font-weight:600;opacity:.78;
      text-shadow:0 0 8px #ff52b1, 0 0 20px #ff52b1;
      pointer-events:none;
    }
  </style>
</head>
<body>
  <canvas id="view"></canvas>
  <div class="label">Nova • Icosaedro</div>

  <!-- Shader 3D (Three + Toon + Bloom). Import JSM de CDN; fallback sem bloom se falhar. -->
  <script type="module">
  const params = new URLSearchParams(location.search);
  const SOLID_PARAM = (params.get('solid')||'icosa').toLowerCase();
  const ALPHA = parseFloat(params.get('alpha')||getComputedStyle(document.documentElement).getPropertyValue('--ballOpacity')) || 0.68;
  const ROT_S = parseFloat(params.get('rs')||getComputedStyle(document.documentElement).getPropertyValue('--rotateSpeed')) || 0.55;
  const BREATH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--breath')) || 0.08;
  const BLOOM_STRENGTH = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bloomStrength')) || 0.85;
  const BLOOM_RADIUS   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bloomRadius')) || 0.22;
  const BLOOM_THRESH   = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--bloomThreshold')) || 0.24;
  const COLOR = '#ff52b1';

  let audioLevel = 0;
  window.addEventListener('message', (e)=>{ if(e?.data && typeof e.data.audioLevel==='number'){ audioLevel = e.data.audioLevel }});

  const canvas = document.getElementById('view');
  const DPR = Math.min(2, window.devicePixelRatio||1);

  function size(renderer,camera) {
    const w = innerWidth, h = innerHeight;
    renderer.setPixelRatio(DPR);
    renderer.setSize(w,h,false);
    camera.aspect = w/h; camera.updateProjectionMatrix();
  }

  function makeGeometry(kind, THREE) {
    switch(kind){
      case 'cube': case 'hexa': return new THREE.BoxGeometry(1,1,1, 1,1,1);
      case 'tetra': return new THREE.TetrahedronGeometry(1);
      case 'octa': return new THREE.OctahedronGeometry(1);
      case 'dodeca': return new THREE.DodecahedronGeometry(1);
      case 'icosa': return new THREE.IcosahedronGeometry(1);
      default: return new THREE.BoxGeometry(1,1,1);
    }
  }

  function gradientMap(THREE) {
    // 5 band toon gradient
    const steps = 5;
    const data = new Uint8Array(steps*3);
    for(let i=0;i<steps;i++) {
      const v = Math.round((i/(steps-1))*255);
      data[i*3+0] = v; data[i*3+1] = v; data[i*3+2] = v;
    }
    const tex = new THREE.DataTexture(data, steps, 1, THREE.RGBFormat);
    tex.needsUpdate = true;
    return tex;
  }

  async function init() {
    // Import core + postprocessing (try, then fallback)
    const THREE = await import('https://unpkg.com/three@0.155.0/build/three.module.js');
    let POST = null;
    try {
      const [
        { EffectComposer },
        { RenderPass },
        { UnrealBloomPass }
      ] = await Promise.all([
        import('https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/EffectComposer.js'),
        import('https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/RenderPass.js'),
        import('https://unpkg.com/three@0.155.0/examples/jsm/postprocessing/UnrealBloomPass.js'),
      ]);
      POST = { EffectComposer, RenderPass, UnrealBloomPass };
    } catch(err) {
      console.warn('[Archetype]', 'Postprocessing indisponível; executando sem bloom.', err);
    }

    // Scene
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 50);
    camera.position.set(0,0,3.4);

    const renderer = new THREE.WebGLRenderer({ canvas, alpha:true, antialias:true, powerPreference:'high-performance' });
    size(renderer,camera);
    addEventListener('resize', ()=> size(renderer,camera));

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff, 0.55));
    const keyL = new THREE.DirectionalLight(0xffffff, 0.85); keyL.position.set(3,2,4); scene.add(keyL);
    const rimL = new THREE.DirectionalLight(0x66b3ff, 0.35); rimL.position.set(-3,-2,-4); scene.add(rimL);

    // Solid
    const geo = makeGeometry(SOLID_PARAM, THREE);
    const mat = new THREE.MeshToonMaterial({
      color: COLOR, transparent:true, opacity: ALPHA,
      gradientMap: gradientMap(THREE),
      emissive: COLOR, emissiveIntensity: 0.12
    });
    const mesh = new THREE.Mesh(geo, mat); scene.add(mesh);

    // Wireframe/edges
    const wire = new THREE.LineSegments(new THREE.EdgesGeometry(geo), new THREE.LineBasicMaterial({
      color: 0xffffff, transparent:true, opacity: Math.min(1, ALPHA*0.6)
    }));
    scene.add(wire);

    // Composer (optional bloom)
    let composer = null, bloomPass = null;
    if (POST) {
      const { EffectComposer, RenderPass, UnrealBloomPass } = POST;
      composer = new EffectComposer(renderer);
      composer.addPass(new RenderPass(scene, camera));
      bloomPass = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), BLOOM_STRENGTH, BLOOM_RADIUS, BLOOM_THRESH);
      composer.addPass(bloomPass);
      addEventListener('resize', ()=> bloomPass.setSize(innerWidth, innerHeight));
    }

    // Animate
    let t0 = performance.now()*0.001;
    function tick() {
      const t = performance.now()*0.001;
      const dt = t - t0; t0 = t;
      // rotation + breath (audio reactive)
      const breathe = 1 + (BREATH * (0.25 + Math.min(1, audioLevel*2.0)));
      mesh.rotation.x += dt * (ROT_S*0.8);
      mesh.rotation.y += dt * (ROT_S*1.1);
      wire.rotation.copy(mesh.rotation);
      const s = 1.0 * breathe;
      mesh.scale.setScalar(s);
      wire.scale.setScalar(s);

      if (composer) composer.render();
      else renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }

  init().catch(err=>{
    console.error('[Archetype] falhou ao iniciar', err);
    // Mostra um fallback simples
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = 'rgba(255,255,255,.1)';
    ctx.fillRect(0,0,canvas.width,canvas.height);
  });
  </script>
</body>
</html>