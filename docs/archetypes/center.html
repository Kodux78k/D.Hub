
<script>
  (function(){
    try {
      const p = new URLSearchParams(location.search);
      const b = parseFloat(p.get('bubble'));
      if (!isNaN(b)) {
        document.documentElement.style.setProperty('--bubbleOpacity', String(Math.max(0, Math.min(1, b))));
      }
    } catch(e){}
  })();
</script>
<!doctype html><meta charset='utf-8'><title>Center</title><style>
  /* Shader+Bloom patch */
  :root{ --bubbleOpacity:.66; }

  /* Bubble overlay inside iframe (soft translucent circle).
     It respects the host circular mask. */
  .bubble {
    position: fixed;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(50% 50% at 50% 50%, rgba(255,255,255,0.12), rgba(255,255,255,0.0) 60%);
    opacity: var(--bubbleOpacity, .68);
    mix-blend-mode: screen;
  }
  /* Hide 2D canvas when WebGL renderer is active */
  .webgl-on canvas#solid { display: none !important; }
html,body{height:100%;margin:0;background:transparent}</style>
<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.module.js';
import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/postprocessing/UnrealBloomPass.js';


import { RoomEnvironment } from 'https://cdn.jsdelivr.net/npm/three@0.155.0/examples/jsm/environments/RoomEnvironment.js';
const params = new URLSearchParams(location.search);
const KIND = (params.get('solid') || 'icosa').toLowerCase();


const MAT = (params.get('mat') || 'toon').toLowerCase();
const PRESET = (params.get('preset') || '').toLowerCase();
const root = document.documentElement;
const css = getComputedStyle(root);
const line = css.getPropertyValue('--line').trim() || '#8fd3ff';
const bloomMul = parseFloat(css.getPropertyValue('--bloom')) || 1;

// Scene & renderer
const scene = new THREE.Scene();
scene.environment = pmrem.fromScene(new RoomEnvironment(), 0.04).texture;
const camera = new THREE.PerspectiveCamera(28, 1, 0.1, 100);
camera.position.set(0, 0, 4.2);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
const pmrem = new THREE.PMREMGenerator(renderer);
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setClearColor(0x000000, 0);
renderer.domElement.style.position = 'fixed';
renderer.domElement.style.inset = '0';
renderer.domElement.style.width = '100%';
renderer.domElement.style.height = '100%';
document.body.appendChild(renderer.domElement);
document.body.classList.add('webgl-on');

// Geometry
function buildGeometry(kind) {
  switch(kind){
    case 'tetra': return new THREE.TetrahedronGeometry(1, 0);
    case 'hexa':  return new THREE.BoxGeometry(1.6,1.6,1.6, 1,1,1);
    case 'octa':  return new THREE.OctahedronGeometry(1.15, 0);
    case 'icosa': return new THREE.IcosahedronGeometry(1.15, 0);
    case 'dodeca':return new THREE.DodecahedronGeometry(1.15, 0);
    default: return new THREE.IcosahedronGeometry(1.15, 0);
  }
}
const geom = buildGeometry(KIND);

// Shader (Toon + Rim Glow). Bloom will lift highlights further.
const uniforms = {
  uColor: { value: new THREE.Color(line) },
  uRimStrength: { value: 0.9 },
  uRimPower: { value: 2.25 },
  uTime: { value: 0 }
};

const vert = `
  varying vec3 vNormal;
  varying vec3 vViewDir;
  void main() {
    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
    vNormal = normalize(normalMatrix * normal);
    vViewDir = normalize(-mvPosition.xyz);
    gl_Position = projectionMatrix * mvPosition;
  }
`;

const frag = `
  precision highp float;
  varying vec3 vNormal;
  varying vec3 vViewDir;
  uniform vec3 uColor;
  uniform float uRimStrength;
  uniform float uRimPower;
  // Simple cool-to-warm ramp for toon-ish bands
  float toon(float x){
    float bands = floor(x*4.0)/4.0; // 4 levels
    return bands;
  }
  void main(){
    float ndotv = max(dot(normalize(vNormal), normalize(vViewDir)), 0.0);
    float rim = pow(1.0 - ndotv, uRimPower);
    float shade = toon(ndotv*0.85 + 0.15);
    vec3 base = uColor * (0.25 + 0.75*shade);
    vec3 glow = vec3(1.0) * rim * uRimStrength;
    gl_FragColor = vec4(base + glow, 1.0);
  }
`;

const mat = new THREE.ShaderMaterial({
  uniforms, vertexShader: vert, fragmentShader: frag,
  transparent: true, side: THREE.DoubleSide
});
let mesh;
if (MAT === 'glass') {
  const matPhys = new THREE.MeshPhysicalMaterial({
    color: new THREE.Color(line),
    metalness: 0.0,
    roughness: 0.08,
    transmission: 1.0,
    thickness: 0.8,
    ior: 1.5,
    clearcoat: 1.0,
    clearcoatRoughness: 0.08,
    envMapIntensity: 1.0
  });
  mesh = new THREE.Mesh(geom, matPhys);
} else {
  mesh = new THREE.Mesh(geom, mat);
}

scene.add(mesh);

// Wireframe accent
const edges = new THREE.EdgesGeometry(geom);
const wire = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: new THREE.Color(line).offsetHSL(0,0,-0.15), transparent: true, opacity: 0.8 }));
scene.add(wire);

// Composer + Bloom
const composer = new EffectComposer(renderer);
composer.addPass(new RenderPass(scene, camera));
const bloom = new UnrealBloomPass(new THREE.Vector2(1,1), 0.85 * bloomMul, 0.25, 0.88);
composer.addPass(bloom);

// Handle resize
function resize(){
  const w = window.innerWidth;
  const h = window.innerHeight;
  renderer.setSize(w, h, false);
  composer.setSize(w, h, false);
  camera.aspect = Math.max(w/h, 0.0001);
  camera.updateProjectionMatrix();
}
addEventListener('resize', resize, false);
resize();

// Animate
let t0 = performance.now();
function tick(){
  const t = performance.now()*0.001;
  uniforms.uTime.value = t;
  mesh.rotation.x = t*0.36;
  mesh.rotation.y = t*0.52;
  wire.rotation.copy(mesh.rotation);
  composer.render();
  requestAnimationFrame(tick);
}
tick();
</script>
