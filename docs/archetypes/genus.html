<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Genus · KOBLLUX</title>
  <style>
    html,body,canvas { margin:0; padding:0; width:100%; height:100%; background: transparent; }
    body { overflow:hidden; }
    /* Quando o host quiser um "overlay invisível", este arquivo já vem com fundo transparente. */
  </style>
</head>
<body>
<script type="module">
import * as THREE from 'https://unpkg.com/three@0.157.0/build/three.module.js';
import { EffectComposer } from 'https://unpkg.com/three@0.157.0/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'https://unpkg.com/three@0.157.0/examples/jsm/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'https://unpkg.com/three@0.157.0/examples/jsm/postprocessing/UnrealBloomPass.js';

// ==== Params (URL) ====
const q = new URLSearchParams(location.search);
const BLOOM = q.get('bloom') !== '0';
const BLOOM_STRENGTH = parseFloat(q.get('bs') || '1.2');
const BLOOM_RADIUS   = parseFloat(q.get('br') || '0.45');
const BLOOM_THRESH   = parseFloat(q.get('bt') || '0.2');
const EMISSIVE_INT   = parseFloat(q.get('emi') || '1.35');
const TOON_STEPS     = Math.max(2, parseInt(q.get('steps') || '4', 10));
const WIRE_OPACITY   = Math.min(1, Math.max(0, parseFloat(q.get('wire') || '0.28')));
const ROT_SPEED      = parseFloat(q.get('rot') || '0.22');
const PULSE_GAIN     = parseFloat(q.get('gain') || '1.5'); // quanto o áudio "respira"

// ==== Archetype→Solid mapping (Platonic + duals) ====
const ARCH = 'genus';
const MAP = {
  atlas:'hexahedron',
  nova:'tetrahedron',
  vitalis:'octahedron',
  pulse:'icosahedron',
  artemis:'octahedron',
  serena:'dodecahedron',
  kaos:'tetrahedron',
  genus:'hexahedron',
  lumine:'icosahedron',
  solus:'octahedron',
  rhea:'dodecahedron',
  aion:'icosahedron'
};
const DUAL = {
  tetrahedron:'tetrahedron',
  hexahedron:'octahedron',
  octahedron:'hexahedron',
  dodecahedron:'icosahedron',
  icosahedron:'dodecahedron'
};

// ==== Blue‑1 palette ====
const BLUE1 = {
  base:  0x0C2CF6, // indigo
  edge:  0x00C2FF, // cyan
  fill:  0x1B63FF, // electric
  emis:  0x4FC3FF  // emissive-ish
};

// Create toon gradient texture (N steps)
function makeToonGradient(steps=4) {
  const size = steps;
  const cnv = document.createElement('canvas');
  cnv.width = size; cnv.height = 1;
  const g = cnv.getContext('2d');
  const grd = g.createLinearGradient(0,0,size,0);
  grd.addColorStop(0.0, '#0b122e');
  for (let i=1;i<steps-1;i++) {
    const t = i/(steps-1);
    // mix between base and cyan
    const c = t<.5 ? '#123bf0' : '#18a8ff';
    grd.addColorStop(t, c);
  }
  grd.addColorStop(1.0, '#8ae6ff');
  g.fillStyle = grd; g.fillRect(0,0,size,1);
  const tex = new THREE.CanvasTexture(cnv);
  tex.minFilter = THREE.NearestFilter;
  tex.magFilter = THREE.NearestFilter;
  tex.generateMipmaps = false;
  return tex;
}

function geometryFor(name) {
  switch (name) {
    case 'tetrahedron': return new THREE.TetrahedronGeometry(1.25, 0);
    case 'hexahedron':  return new THREE.BoxGeometry(1.8, 1.8, 1.8);
    case 'octahedron':  return new THREE.OctahedronGeometry(1.35, 0);
    case 'dodecahedron':return new THREE.DodecahedronGeometry(1.35, 0);
    case 'icosahedron':
    default: return new THREE.IcosahedronGeometry(1.35, 0);
  }
}

let audioLevel = 0, audioSmooth = 0;

window.addEventListener('message', (ev) => {
  const d = ev.data;
  if (d && d.type === 'audio') {
    audioLevel = Math.max(0, Math.min(1, Number(d.level) || 0));
  }
});

// ==== Scene ====
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 100);
camera.position.set(0, 0, 4.5);

const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
renderer.setPixelRatio(devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

// Lights
const amb = new THREE.AmbientLight(0xffffff, 0.18);
scene.add(amb);
const key = new THREE.PointLight(BLUE1.base, 1.2, 20); key.position.set(4, 3, 5); scene.add(key);
const rim = new THREE.PointLight(BLUE1.edge, 0.9, 20); rim.position.set(-4,-2,3); scene.add(rim);

// Solid
const baseSolid = MAP[ARCH] || 'icosahedron';
let geom = geometryFor(baseSolid);
const toonTex = makeToonGradient(TOON_STEPS);
const mat = new THREE.MeshToonMaterial({
  color: BLUE1.fill,
  gradientMap: toonTex,
  emissive: new THREE.Color(BLUE1.emis),
  emissiveIntensity: EMISSIVE_INT,
  wireframe: false
});
const mesh = new THREE.Mesh(geom, mat);
mesh.castShadow = false; mesh.receiveShadow = false;
scene.add(mesh);

// Wireframe overlay (edges)
const edges = new THREE.EdgesGeometry(geom);
const lineMat = new THREE.LineBasicMaterial({ color: BLUE1.edge, transparent: true, opacity: WIRE_OPACITY });
let wire = new THREE.LineSegments(edges, lineMat);
scene.add(wire);

// Postprocessing
let composer = null;
if (BLOOM) {
  composer = new EffectComposer(renderer);
  composer.addPass(new RenderPass(scene, camera));
  const bloom = new UnrealBloomPass(new THREE.Vector2(innerWidth, innerHeight), BLOOM_STRENGTH, BLOOM_RADIUS, BLOOM_THRESH);
  composer.addPass(bloom);
}

// Resize
window.addEventListener('resize', () => {
  camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
  if (composer) composer.setSize(innerWidth, innerHeight);
});

// Animate
let t = 0;
function animate() {
  requestAnimationFrame(animate);
  t += 0.016;
  audioSmooth = audioSmooth*0.85 + audioLevel*0.15;
  const breathe = 1.0 + audioSmooth * PULSE_GAIN * 0.6;
  mesh.rotation.y += ROT_SPEED*0.016*60;
  mesh.rotation.x += 0.005;
  mesh.scale.setScalar(breathe);
  wire.scale.copy(mesh.scale);
  if (composer) composer.render(); else renderer.render(scene, camera);
}
animate();

// ==== Dual toggle (D key) ====
document.addEventListener('keydown', (ev) => {
  if (ev.key.toLowerCase() === 'd') toggleDual();
});

function toggleDual() {
  const cur = MAP[ARCH] || 'icosahedron';
  const alt = DUAL[cur] || cur;
  if (!alt) return;
  const g2 = geometryFor(alt);
  mesh.geometry.dispose();
  wire.geometry.dispose();
  mesh.geometry = g2;
  const e2 = new THREE.EdgesGeometry(g2);
  wire.geometry = e2;
}

// ==== Public API (for host page) ====
window.Arch = {
  setEmissive(i=1.2) { mat.emissiveIntensity = Number(i)||1.2; },
  setBloom(s=1.2, r=0.45, t=0.2) {
    if (!composer) return;
    const pass = composer.passes.find(p => p instanceof UnrealBloomPass);
    if (pass) { pass.strength = Number(s)||1.2; pass.radius = Number(r)||0.45; pass.threshold = Number(t)||0.2; }
  },
  setToonSteps(n=4) {
    const tex = makeToonGradient(Math.max(2, parseInt(n,10)||4));
    mat.gradientMap = tex; mat.needsUpdate = true;
  }
};
</script>
</body>
</html>